<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini RAG (Local)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
  :root {
    /* still dark, but brighter + higher contrast */
    --bg: #0e141b;        /* was #0b0f14 */
    --card: #151e28;      /* was #121820 */
    --text: #f2f6fb;      /* was #e7edf3 */
    --muted: #b7c4d1;     /* was #9fb0bf */
    --border: #2a394a;    /* was #1f2a36 */
    --accent: #3aa0ff;
    --field: #121a24;     /* inputs/pre background */
  }

  * { box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    max-width: 980px;
    margin: 32px auto;
    padding: 0 16px 48px;
    line-height: 1.6;                 /* easier reading */
  }

  h1 { font-size: 28px; margin: 0 0 16px; letter-spacing: .2px; font-weight: 700; }
  h2 {
    font-size: 18px;
    margin: 0 0 10px;
    color: var(--text);        /* use full text color */
    font-weight: 700;
    letter-spacing: 0.3px;
    }


  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 18px;
    margin: 18px 0;
    box-shadow: 0 10px 24px rgba(0,0,0,0.28); /* slightly stronger but soft */
  }

  .row { display: grid; gap: 12px; }

  textarea, input {
    width: 100%;
    background: var(--field);         /* brighter than before */
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 14px;
    outline: none;
    font-size: 15px;                  /* bigger text */
  }
  textarea::placeholder, input::placeholder { color: #7f95a8; }
  textarea:focus, input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(58,160,255,.15); }

  button {
    border: 1px solid var(--border);
    background: linear-gradient(180deg, #1a2330, #131b25);
    color: var(--text);
    padding: 11px 14px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 700;
  }
  button:hover { border-color: var(--accent); transform: translateY(-0.5px); }

  .chunks, pre {
    background: var(--field);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    line-height: 1.55;                /* more legible blocks */
    white-space: pre-wrap;            /* wrap long lines */
  }

  .muted { color: var(--muted); font-size: 0.92em; }
  .stack { display: grid; gap: 6px; }

  footer {
    margin-top: 20px;
    color: var(--muted);
    font-size: 12px;
    text-align: center;
  }

  .row button,
.row input[type="file"] {
  margin-right: 8px;
}


.answer-card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px 14px;
  line-height: 1.55;
  white-space: pre-wrap;
}

.badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid var(--border);
  margin-right: 6px;
  font-size: 12px;
  color: var(--muted);
}
.chunks-list { display: grid; gap: 10px; }
.chunk-card {
  background: var(--field);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 10px;
}
.chunk-title { font-weight: 700; font-size: 13px; margin-bottom: 6px; }
.chunk-score { font-size: 12px; color: var(--muted); }

.row + .row { margin-top: 12px; }
.hidden { display: none; }
</style>


</head>
<body>
  <h1>Mini RAG (Local Embeddings)</h1>

  <section class="card">
    <h2>1) Ingest text</h2>
    <div class="row">
      <textarea id="ingestText" rows="6" placeholder="Paste any text here..."></textarea>
      <button id="ingestBtn">Ingest</button>
      <div id="ingestOut" class="muted"></div>
    </div>
  </section>

  <section class="card">
    <h2>2) Ask</h2>
    <div class="row">
      <input id="q" placeholder="Ask a question..." />
      <button id="askBtn">Ask</button>
      <div class="row">
      <h3>Top chunks</h3>
      <div id="chunks" class="chunks"></div>
    </div>
      <div class="row">
        <h3>Answer (uses API if available)</h3>
        <div id="answer" class="answer-card"></div>
        <div class="muted">If empty, your API quota is out — retrieval still works above.</div>
      </div>
    </div>
  </section>

  <section class="card">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <h2 style="margin:0;">3) Stored chunks</h2>
    <button id="toggleListBtn">Show chunks</button>
  </div>
  <div class="row" id="listWrap" class="hidden"> <!-- starts hidden via JS -->
    <input id="filterChunks" placeholder="Filter preview text..." />
    <button id="listBtn">Refresh</button>

    <div id="listContainer" class="chunks-list" style="margin-top:8px;"></div>
  </div>
</section>



  <section class="card">
  <h2>3) Utilities</h2>
  <div class="row">
    <button id="clearBtn">Clear memory</button>
    <button id="exportBtn">Export memory (.json)</button>
  </div>
  <div class="row" style="margin-top: 12px;">
    <input type="file" id="uploadFile" accept=".txt" />
    <button id="uploadBtn">Import & Ingest File</button>
  </div>
  <div class="row" style="margin-top: 12px;">
  <button id="pingBtn">Ping server</button>
  <div id="pingOut" class="muted"></div>
</div>
  <div id="utilOut" class="muted"></div>
</section>


<script>
    function linkCitations(text) {
  // turns "...[#1] and [#2]" into anchors targeting chunk cards
  return text.replace(/\[#(\d+)\]/g, (_m, n) => {
    const id = `chunk-${n}`;
    return `<a href="#${id}" class="badge">#${n}</a>`;
  });
}

function renderChunks(container, chunks) {
  if (!chunks?.length) { container.textContent = 'No chunks.'; return; }
  container.innerHTML = chunks.map((c, i) => `
    <div class="chunk-card" id="chunk-${i+1}">
      <div class="chunk-title">[#${i+1}] <span class="chunk-score">(score ${c.score})</span></div>
      <div>${c.text.replace(/</g,'&lt;')}</div>
    </div>
  `).join('\n');
}



window.addEventListener('DOMContentLoaded', () => {

    async function postJSON(url, body) {
      const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }
    async function getJSON(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    }

    document.getElementById('ingestBtn').onclick = async () => {
      const text = document.getElementById('ingestText').value.trim();
      const out = document.getElementById('ingestOut');
      out.textContent = 'Ingesting...';
      try {
        const res = await postJSON('/ingest', { text });
        out.textContent = JSON.stringify(res);
      } catch (e) {
        out.textContent = e.message;
      }
    };

    document.getElementById('askBtn').onclick = async () => {
  const q = document.getElementById('q').value.trim();
  const chunksEl = document.getElementById('chunks');
  const ansEl = document.getElementById('answer');
  if (!q) return;

  chunksEl.textContent = 'Searching...'; ansEl.textContent = '';
  try {
    const res = await getJSON(`/ask?q=${encodeURIComponent(q)}&k=4`);

    // render chunks as small cards with anchors
    renderChunks(chunksEl, res.chunks);

    // beautify answer: link [#1] citations to the chunk cards
    const html = linkCitations(res.answer || '');
    ansEl.innerHTML = html || '<span class="muted">No answer produced.</span>';
  } catch (e) {
    chunksEl.textContent = e.message;
  }

};


document.getElementById('clearBtn').onclick = async () => {
    const r = await fetch('/clear', { method: 'POST' });
    document.getElementById('clearOut').textContent = r.ok ? 'Cleared!' : 'Failed to clear.';
};



//listbtn handler
async function refreshChunks(filter = '') {
  const container = document.getElementById('listContainer');
  container.innerHTML = '<div class="muted">Loading…</div>';
  try {
    const r = await fetch('/list');
    const data = await r.json();
    const items = (data.items || []);
    const filtered = filter
      ? items.filter(it => it.preview.toLowerCase().includes(filter.toLowerCase()))
      : items;

    if (!filtered.length) {
      container.innerHTML = '<div class="muted">No chunks found.</div>';
      return;
    }

    container.innerHTML = filtered.map((it, idx) => `
      <div class="chunk-card">
        <div class="chunk-title">#${it.idx + 1} (id ${it.id})</div>
        <div>${it.preview.replace(/</g,'&lt;')}</div>
      </div>
    `).join('\n');
  } catch (e) {
    container.innerHTML = `<div class="muted">${e.message}</div>`;
  }
}

// --- Stored chunks show/hide
const listWrap = document.getElementById('listWrap');
const toggleListBtn = document.getElementById('toggleListBtn');

// start hidden
listWrap.classList.add('hidden');

toggleListBtn.onclick = () => {
  const nowHidden = listWrap.classList.toggle('hidden');
  toggleListBtn.textContent = nowHidden ? 'Show chunks' : 'Hide chunks';
  if (!nowHidden) {
    // when opening, refresh immediately
    const filt = document.getElementById('filterChunks').value.trim();
    refreshChunks(filt);
  }
};


document.getElementById('listBtn').onclick = () => {
  const filt = document.getElementById('filterChunks').value.trim();
  refreshChunks(filt);
};
document.getElementById('filterChunks').addEventListener('input', (e) => {
  refreshChunks(e.target.value.trim());
});

// initial load once
refreshChunks('');
  


  // Export (already working)
document.getElementById('exportBtn').onclick = async () => {
  const r = await fetch('/export');
  const blob = await r.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'memory.json';
  a.click();
  URL.revokeObjectURL(url);
};

document.getElementById('uploadBtn').onclick = async () => {
  const fileInput = document.getElementById('uploadFile');
  const out = document.getElementById('utilOut');

  try {
    if (!fileInput) throw new Error('#uploadFile not found');
    if (!fileInput.files || fileInput.files.length === 0) {
      out.textContent = 'Choose a .txt file first!';
      return;
    }
    const file = fileInput.files[0];
    out.textContent = `Selected: ${file.name} (${file.size} bytes)`;

    if (!file.name.toLowerCase().endsWith('.txt')) {
      out.textContent = 'Only .txt supported right now.';
      return;
    }

    out.textContent = 'Reading file...';
    const text = await file.text();
    out.textContent = `Read ${text.length} chars; sending to /ingest...`;

    const r = await fetch('/ingest', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });

    if (!r.ok) {
      const msg = await r.text();
      out.textContent = `Server error ${r.status}: ${msg}`;
      return;
    }

    const data = await r.json();
    out.textContent = `Uploaded! Added ${data.chunksAdded} chunks. Total: ${data.totalChunks}`;
  } catch (e) {
    out.textContent = `Upload failed: ${e.message}`;
  }
};



  document.getElementById('pingBtn').onclick = async () => {
  const out = document.getElementById('pingOut');
  out.textContent = 'Pinging...';
  try {
    const r = await fetch('/ping');
    out.textContent = r.ok ? 'Server OK ✅' : `Ping failed: ${r.status}`;
  } catch (e) {
    out.textContent = `Ping error: ${e.message}`;
  }
};

}); // end DOMContentLoaded
</script>
</body>
</html>
